/***** IPEC — Master Builder (owner-agnostic, All-Drives, A→B parity) ******
 * FOLDER A
 *   Name: "INV-XXX-YYYY <Customer>.xlsx"
 *   Items: start row 12, cols A..E → ItemCode, Desc, Qty, UnitPrice, LineTotal
 *   InvoiceTotal: B8
 *   Meta: B1=Invoice, B2=Date, B3=Client, B5=Phone
 *
 * FOLDER B
 *   Name: "IPEC Invoice XXX-YYYY.xlsx"
 *   Items: header row auto-detected (usually row 8), then A..E → Code, Desc, Qty, Unit, Line
 *   Stop at "SUB TOTAL USD"/"TOTAL" row. InvoiceTotal = cell to the right of that label.
 *   Meta (labels in col A): Invoice n° / Date / Bill to|Customer|Client / Phone
 *
 * PARITY LOGIC
 *   Process the latest month tag (YYYY) in A first, then B.
 *   A is considered "present in master" if name OR url OR normalized name matches.
 *   B is considered "present in master" only if BOTH name AND url match (strict).
 *
 * Also:
 *   - Owner-agnostic Drive listing (works in "Shared with me"), All Drives.
 *   - Items enrichment from Items tab (ItemCode→Supplier[G], Category[D], Sub-category[E]).
 *   - Triggers every 30 min (Mon–Sat, 08:00–17:30) for builder + Items copier.
 *****************************************************************************/

const CFG = {
  // -------- FOLDERS --------
  folderAId: '1SrLECEwccnm_304DRxJW47I2sMJ0djxH',
  folderBId: '1q2I1jiFyTACvxjG82v89qPl0_9QsrXCg',

  // -------- MASTER --------
  MASTER_SHEET_ID: '1jp8Lf87sGan89ZuvT5X7tCreXFnkXDeTOnNwGkJDAik',
  MASTER_TAB: 'Sheet1',
  OUT_HEAD: [
    'InvoiceName','InvoicePath','Type','Client','Phone','ItemCode','ProductDescription',
    'Qty','UnitPrice','LineTotal','InvoiceTotal','Supplier','Category','Sub-category','InvoiceDate'
  ],

  // -------- ITEMS ENRICHMENT (same spreadsheet) --------
  ITEMS_TAB: 'Items',
  ITEMS_KEY_COL: 1,        // A: ItemCode
  ITEMS_CATEGORY_COL: 4,   // D: Category
  ITEMS_SUBCATEGORY_COL: 5,// E: Sub-category
  ITEMS_SUPPLIER_COL: 7,   // G: Supplier

  // -------- EXCEL IMPORT (Drive Advanced API v3) --------
  EXCEL_MIMES: [
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.ms-excel'
  ],
  DATA_SHEET_CANDIDATES: ['INVOICE','Invoice','INV 1','INV1','Sheet1','Sheet','Feuil1','Feuille1','Data','Export'],
  CLEANUP_TEMP_IMPORTS: true,

  // -------- SYNTHÈSE source (Items tab incremental copy) --------
  ITEMS_SOURCE_ID: '1UoLZe0zs4moThJKqIXJPF_td1ELf5yDz',
  ITEMS_SOURCE_TAB: 'Synthese',
  ITEMS_SOURCE_START_ROW: 1049,
  PROP_ITEMS_LAST_SRC_ROW: 'ITEMS_LAST_SRC_ROW',

  // -------- CHUNKING / TIME GUARD --------
  MAX_FILES_PER_RUN: 500,
  TIME_GUARD_MS: 5 * 60 * 1000
};
const API_KEY = '09214534';

// helper to always emit JSON (and avoid HTML error pages)
function jsonOut(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}
/* =============================== MAIN BUILDER =============================== */

function BuildMasterIncremental() {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(30 * 1000)) { Logger.log('Lock busy; skipping.'); return; }

  try {
    const ss = openSpreadsheetWithRetry_(CFG.MASTER_SHEET_ID);
    const sh = getOrCreateSheetWithHeader_(ss, CFG.MASTER_TAB, CFG.OUT_HEAD);

    // Latest tag/number in each folder (by filename)
    const fA = getFolderMaxInfo_(CFG.folderAId, parseInvAInfo_); // {num, tag} or {0,''}
    const fB = getFolderMaxInfo_(CFG.folderBId, parseInvBInfo_);
    Logger.log(`Folder maxima → A=${fA.num || 0}-${fA.tag || '----'}  B=${fB.num || 0}-${fB.tag || '----'}`);

    const enrich = loadItemsMap_(ss);
    const t0 = Date.now();
    let processed = 0;

    // Import only files missing in Master for given Type+tag
    const processFolderByMissing = (folderId, whereLabel, parseInfoFn, tag, rowReader, metaReader) => {
      if (!tag) { Logger.log(`Folder ${whereLabel}: no Excel files.`); return true; }

      // All Excel files for this tag (owner-agnostic; All Drives)
      const folderFiles = listFolderFilesForTag_(folderId, parseInfoFn, tag); // [{file,num,tag}]
      Logger.log(`Folder ${folderId} tag ${tag}: found ${folderFiles.length} Excel file(s) across all drives.`);

      // What Master already has for this Type & tag
      const presence = listMasterPresenceForTypeTag_(sh, whereLabel, tag); // {names:Set, urls:Set, normNames:Set}

      // Missing rule:
      //  - A: present if name OR url OR normalized-name matches
      //  - B: present only if BOTH name AND url match
      const missing = folderFiles
        .filter(x => {
          const n  = x.file.getName();
          const u  = x.file.getUrl();
          const nn = normalizeName_(n);
          if (whereLabel === 'B') return !(presence.names.has(n) && presence.urls.has(u));
          return !(presence.names.has(n) || presence.urls.has(u) || presence.normNames.has(nn));
        })
        .sort((a,b) => a.num - b.num);

      Logger.log(`Folder ${whereLabel} ${tag}: ${missing.length} missing (${missing.map(x=>x.num).join(', ') || 'none'})`);

      for (let i = 0; i < missing.length; i++) {
        if (processed >= CFG.MAX_FILES_PER_RUN || (Date.now() - t0) > CFG.TIME_GUARD_MS) {
          scheduleAutoContinue_();
          return false; // stop now; resume next run
        }

        const { file } = missing[i];
        const fileName = file.getName();
        const fileUrl  = file.getUrl();

        try {
          const openRes = importExcelToSheet_v3_(file);
          try {
            const dataSh = pickDataSheet_(openRes.spreadsheet);
            if (!dataSh) { processed++; continue; }

            const values = readRangeValuesWithRetry_(dataSh.getDataRange());
            const rows   = rowReader(values);
            if (!rows.length) { Logger.log(`[${whereLabel}] ${fileName} produced 0 items.`); processed++; continue; }

            const meta   = metaReader(values);

            const block = rows.map(r => {
              const ic  = toStr(r.itemCode).toUpperCase();
              const enr = enrich.get(ic) || { supplier:'', category:'', subcategory:'' };
              return [
                fileName, fileUrl, whereLabel,
                meta.client, meta.phone,
                r.itemCode, r.description, r.qty, r.unitPrice, r.lineTotal,
                meta.invoiceTotal, enr.supplier, enr.category, enr.subcategory, meta.date
              ];
            });

            sh.getRange(sh.getLastRow()+1, 1, block.length, CFG.OUT_HEAD.length).setValues(block);
          } finally {
            if (CFG.CLEANUP_TEMP_IMPORTS && openRes.toDelete) {
              try { Drive.Files.delete(openRes.toDelete, { supportsAllDrives:true }); } catch (_) {}
            }
          }
        } catch (e) {
          Logger.log('Failed on file ' + fileName + ' → ' + (e && e.message ? e.message : e));
        }

        processed++;
      }

      return true; // no more missing for this tag
    };

    // Always process A first, then B
    if (!processFolderByMissing(CFG.folderAId, 'A', parseInvAInfo_, fA.tag, readItemsA_, metaA_)) return;
    if (!processFolderByMissing(CFG.folderBId, 'B', parseInvBInfo_, fB.tag, readItemsB_, metaB_)) return;

    Logger.log('Done (missing-number; A uses name/url/normalized-name, B uses strict name+url).');
  } finally {
    lock.releaseLock();
  }
}

/* ====================== Items updater (Synthèse → Items) ====================== */

function UpdateItemsFromSyntheseIncremental() {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(30 * 1000)) { Logger.log('Items lock busy; skipping.'); return; }

  try {
    const props    = PropertiesService.getDocumentProperties();
    const ssMaster = openSpreadsheetWithRetry_(CFG.MASTER_SHEET_ID);
    const shItems  = ssMaster.getSheetByName(CFG.ITEMS_TAB) || ssMaster.insertSheet(CFG.ITEMS_TAB);

    const ssSrc = openSpreadsheetWithRetry_(CFG.ITEMS_SOURCE_ID);
    const shSrc = ssSrc.getSheetByName(CFG.ITEMS_SOURCE_TAB) || ssSrc.getSheets()[0];

    const srcLastRow = shSrc.getLastRow();
    if (srcLastRow < CFG.ITEMS_SOURCE_START_ROW) return;

    let lastCopied = parseInt(props.getProperty(CFG.PROP_ITEMS_LAST_SRC_ROW) || (CFG.ITEMS_SOURCE_START_ROW - 1), 10);
    if (isNaN(lastCopied) || lastCopied < CFG.ITEMS_SOURCE_START_ROW - 1) lastCopied = CFG.ITEMS_SOURCE_START_ROW - 1;

    const start = lastCopied + 1;
    if (start > srcLastRow) return;

    const srcLastCol = shSrc.getLastColumn();
    const numRows    = srcLastRow - start + 1;
    const values     = readRangeValuesWithRetry_(shSrc.getRange(start, 1, numRows, srcLastCol));

    if (values.length) {
      shItems.getRange(shItems.getLastRow()+1, 1, values.length, srcLastCol).setValues(values);
      props.setProperty(CFG.PROP_ITEMS_LAST_SRC_ROW, String(srcLastRow));
    }
  } finally {
    lock.releaseLock();
  }
}

/* ========================= Windowed wrappers & triggers ========================= */

// Only run Mon–Sat, 08:00–17:30
function withinWindow_() {
  const now = new Date();
  const dow = now.getDay();              // 0=Sun .. 6=Sat
  if (dow === 0) return false;           // exclude Sunday
  const mins = now.getHours() * 60 + now.getMinutes();
  return mins >= 8 * 60 && mins <= 17 * 60 + 30; // 08:00 .. 17:30
}
function nextAllowedTime_() {
  const now = new Date();
  if (withinWindow_()) {
    const d = new Date(now);
    const m = d.getMinutes();
    const add = (m % 30 === 0 && d.getSeconds() < 20) ? 0 : (30 - (m % 30));
    d.setMinutes(m + add, 10, 0);  // next :00/:30 + 10s
    return d;
  }
  const d = new Date(now);
  d.setSeconds(0, 0);
  const mins = d.getHours() * 60 + d.getMinutes();
  if (mins > 17 * 60 + 30) d.setDate(d.getDate() + 1);
  d.setHours(8, 0, 10, 0);
  while (d.getDay() === 0) d.setDate(d.getDate() + 1); // skip Sunday
  return d;
}

function BuildMasterIncremental_Gated() {
  if (!withinWindow_()) { Logger.log('Outside window; skipping BuildMasterIncremental'); return; }
  BuildMasterIncremental();
}
function UpdateItemsFromSyntheseIncremental_Gated() {
  if (!withinWindow_()) { Logger.log('Outside window; skipping UpdateItemsFromSyntheseIncremental'); return; }
  UpdateItemsFromSyntheseIncremental();
}

function scheduleAutoContinue_() {
  try {
    ScriptApp.getProjectTriggers()
      .filter(t =>
        t.getHandlerFunction && t.getHandlerFunction() === 'BuildMasterIncremental_Gated' &&
        t.getEventType && t.getEventType() === ScriptApp.EventType.CLOCK
      )
      .forEach(t => { try { ScriptApp.deleteTrigger(t); } catch (_) {} });

    const when = nextAllowedTime_();
    ScriptApp.newTrigger('BuildMasterIncremental_Gated').timeBased().at(when).create();
    Logger.log('Auto-continue scheduled for: ' + when);
  } catch (err) {
    Logger.log('Auto-continue skipped: ' + err);
  }
}

function CreateAllTriggers30_Windowed() {
  ScriptApp.getProjectTriggers().forEach(t => {
    const fn = t.getHandlerFunction && t.getHandlerFunction();
    if (fn === 'BuildMasterIncremental' ||
        fn === 'UpdateItemsFromSyntheseIncremental' ||
        fn === 'BuildMasterIncremental_Gated' ||
        fn === 'UpdateItemsFromSyntheseIncremental_Gated') {
      try { ScriptApp.deleteTrigger(t); } catch (_) {}
    }
  });
  ScriptApp.newTrigger('BuildMasterIncremental_Gated').timeBased().everyMinutes(30).create();
  ScriptApp.newTrigger('UpdateItemsFromSyntheseIncremental_Gated').timeBased().everyMinutes(30).create();
  Logger.log('Windowed 30-min triggers created (Mon–Sat, 08:00–17:30).');
}

/* =============================== Web JSON endpoint =============================== */

// === Helper: fetch a tab via CSV export (owner-agnostic) ===
// Authenticated CSV export (handles private Sheets)
function fetchSheetCsv_(sheetId, gid) {
  const url = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${gid}`;
  const resp = UrlFetchApp.fetch(url, {
    muteHttpExceptions: true,
    followRedirects: true,
    headers: { Authorization: 'Bearer ' + ScriptApp.getOAuthToken() }
  });
  const code = resp.getResponseCode();
  const text = resp.getContentText();

  if (code !== 200) throw new Error(`CSV export failed (${code})`);
  if (/<html[\s>]/i.test(text)) throw new Error('CSV export returned HTML (auth/permission issue).');
  return Utilities.parseCsv(text);
}
function doGet(e){
  try {
    const p       = (e && e.parameter) || {};
    const sheetId = CFG.MASTER_SHEET_ID;

    // --- resolve gid of MASTER_TAB (or best match) ---
    let meta = { gid: p.gid || '' , name: '', score: -1 };
    if (!meta.gid) meta = resolveMasterGid_(sheetId, CFG.MASTER_TAB);

    // --- CSV → rows (with OAuth) ---
    const rows = fetchSheetCsv_(sheetId, meta.gid);
    if (!rows || rows.length < 2) {
      return ContentService.createTextOutput(JSON.stringify({
        error: 'No rows from CSV', gid: meta.gid, tab: meta.name, score: meta.score
      })).setMimeType(ContentService.MimeType.JSON);
    }

    // Column positions (A..O): keep in sync with your OUT_HEAD
    // A InvoiceName, B InvoicePath, C Type, D Client, E Phone, F ItemCode,
    // G ProductDescription, H Qty, I UnitPrice, J LineTotal, K InvoiceTotal,
    // L Supplier, M Category, N Sub-category, O InvoiceDate
    const A=0,B=1,C=2,D=3,E=4,F=5,G=6,H=7,I=8,J=9,K=10,L=11,M=12,N=13,O=14;

    const data = rows.slice(1).map(r => ({
      // identifiers
      InvoiceName:           r[A] || '',
      InvoicePath:           r[B] || '',

      // core fields
      Type:                  r[C] || '',
      Client:                r[D] || '',
      Phone:                 r[E] || '',
      ItemCode:              (r[F] || '').toString().toUpperCase().replace(/\s+/g,''),
      'Product/Description': r[G] || '',
      Qty:                   r[H] || 0,
      UnitPrice:             r[I] || 0,
      LineTotal:             r[J] || '',
      InvoiceTotal:          r[K] || '',

      // ✅ exact columns you requested
      Supplier:              r[L] || '',
      Category:              r[M] || '',
      'Sub-category':        r[N] || '',

      // ✅ date source for Month filter
      Date:                  r[O] || ''
    }));

    const limit = p.limit ? Math.max(0, parseInt(p.limit,10) || 0) : 0;
    const out   = limit > 0 ? data.slice(0, limit) : data;

    return ContentService.createTextOutput(JSON.stringify({ data: out }))
      .setMimeType(ContentService.MimeType.JSON);

  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({ error: String(err) }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

/* ================================ Readers & Meta (DROP-IN) ================================ */

// tiny normalizer for label matching
function _normLbl_(s) {
  return toStr(s)
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // strip accents
    .toLowerCase().replace(/\s+/g,' ').trim();
}

// A invoices: items start at row 12; read A..E; description ALWAYS from col B; stop on blank or TOTAL line
function readItemsA_(values) {
  const isHeaderish = row => {
    const a = _normLbl_(row[0]);
    const b = _normLbl_(row[1]);
    const c = _normLbl_(row[2]);
    return (a === 'model' || a === 'item code' || a === 'code') ||
           (b === 'description' || b === 'designation' || b === 'desc' || b === 'الوصف') ||
           (c === 'qty' || c === 'quantity' || c === 'الكمية');
  };

  const stopOnTotal = row => {
    for (let c = 0; c < Math.min(row.length, 8); c++) {
      const t = _normLbl_(row[c]);
      if (t.includes('total usd') || t === 'total' || t.includes('sub total') || t.includes('subtotal') ||
          t.includes('الاجمالي') || t.includes('المجموع')) return true;
    }
    return false;
  };

  const out = [];
  for (let r = 12 - 1; r < values.length; r++) {
    const row = values[r] || [];
    if (stopOnTotal(row)) break;

    const itemCode  = toStr(row[0]).trim();
    const desc      = toStr(row[1]).trim(); // ← force from column B
    if (!itemCode && !desc) break;          // end of items
    if (isHeaderish(row)) continue;         // skip header line

    const qty       = row[2];
    const unitPrice = row[3];
    const lineTotal = row[4];
    out.push({ itemCode, description: desc, qty, unitPrice, lineTotal });
  }
  return out;
}

function metaA_(values) {
  // 1) fast-path fixed cells (your template)
  const get = (r,c) => toStr((values[r]||[])[c]).trim();
  let invoice     = get(0,1);   // B1
  let date        = get(1,1);   // B2
  let client      = get(2,1);   // B3
  let phone       = get(4,1);   // B5
  let invoiceTotal= get(7,1);   // B8

  // 2) fallbacks: scan first ~35 rows for labeled pairs in A:label / B:value
  const top = Math.min(values.length, 35);
  const lab = {
    inv: new Set(['invoice n°','invoice no','invoice #','invoice','facture','facture n°','n° facture','فاتورة','رقم الفاتورة']),
    date:new Set(['date','invoice date','تاريخ','تاريخ الفاتورة']),
    cli: new Set(['client','customer','bill to','billed to','nom du client','اسم العميل','العميل','الزبون']),
    tel: new Set(['phone','tel','telephone','téléphone','هاتف','تلفون','رقم الهاتف'])
  };

  const getByLabel = (labels) => {
    for (let r = 0; r < top; r++) {
      const a = _normLbl_(values[r]?.[0]);
      if (labels.has(a)) return toStr(values[r]?.[1]).trim();
      // also support B:label / C:value
      const b = _normLbl_(values[r]?.[1]);
      if (labels.has(b)) return toStr(values[r]?.[2]).trim();
    }
    return '';
  };

  if (!invoice) invoice = getByLabel(lab.inv);
  if (!date)    date    = getByLabel(lab.date);
  if (!client)  client  = getByLabel(lab.cli);
  if (!phone)   phone   = getByLabel(lab.tel);

  // total fallback: look for TOTAL/SUBTOTAL anywhere in top 120 cells and read right neighbor
  if (!invoiceTotal) {
    outer: for (let r = 0; r < Math.min(values.length, 120); r++) {
      const row = values[r] || [];
      for (let c = 0; c < Math.min(row.length, 10); c++) {
        const t = _normLbl_(row[c]);
        if (t.includes('sub total') || t.includes('subtotal') || t.includes('total usd') || t === 'total' ||
            t.includes('المجموع') || t.includes('الاجمالي')) {
          invoiceTotal = toStr(row[c + 1] ?? row[4] ?? '').trim();
          break outer;
        }
      }
    }
  }

  return { invoice, date, client, phone, invoiceTotal };
}

// B invoices: auto-detect header; read A..E; description ALWAYS from col B; stop at SUBTOTAL/TOTAL
function readItemsB_(values) {
  const isHeaderA = s => ['item code','item','code'].includes(_normLbl_(s));
  const isHeaderB = s => ['description','designation','desc','الوصف'].includes(_normLbl_(s));
  const isHeaderC = s => _normLbl_((s)) === 'qty' || _normLbl_(s) === 'quantity' || _normLbl_(s) === 'الكمية';
  const isHeaderD = s => _normLbl_(s).replace(/\s+/g,'') === 'u.price';
  const isHeaderE = s => _normLbl_(s).replace(/\s+/g,'') === 't.price';

  let headerRow = -1; // zero-based
  for (let r = 5; r <= Math.min(values.length - 1, 14); r++) {
    const A = (values[r]||[])[0], B = (values[r]||[])[1], C = (values[r]||[])[2], D = (values[r]||[])[3], E = (values[r]||[])[4];
    if (isHeaderA(A) && isHeaderB(B) && (isHeaderC(C) || isHeaderD(D) || isHeaderE(E))) { headerRow = r; break; }
  }
  let start = (headerRow >= 0 ? headerRow + 2 : 9);
  start = Math.max(1, start);

  const stopOnLabel = row => {
    for (let c = 0; c < Math.min(row.length, 8); c++) {
      const t = _normLbl_(row[c]);
      if (t.includes('sub total') || t.includes('subtotal') || t.includes('total usd') || t === 'total' ||
          t.includes('المجموع') || t.includes('الاجمالي')) return true;
    }
    return false;
  };
  const isHeaderish = row => {
    const a = _normLbl_(row[0]);
    const b = _normLbl_(row[1]);
    const c = _normLbl_(row[2]);
    return (a === 'item code' || a === 'item' || a === 'code') ||
           (b === 'description' || b === 'designation' || b === 'desc' || b === 'الوصف') ||
           (c === 'qty' || c === 'quantity' || c === 'الكمية');
  };

  const out = [];
  for (let r = start - 1; r < values.length; r++) {
    const row = values[r] || [];
    if (stopOnLabel(row)) break;

    const itemCode  = toStr(row[0]).trim();
    const desc      = toStr(row[1]).trim(); // ← force from column B
    if (!itemCode && !desc) break;
    if (isHeaderish(row)) continue;

    const qty       = row[2];
    const unitPrice = row[3];
    const lineTotal = row[4];
    out.push({ itemCode, description: desc, qty, unitPrice, lineTotal });
  }
  return out;
}

function metaB_(values) {
  const topRows = Math.min(values.length, 40);

  // supported labels (EN/FR/AR)
  const labs = {
    inv:  new Set(['invoice n°','invoice no','invoice #','invoice','facture','facture n°','n° facture','فاتورة','رقم الفاتورة']),
    date: new Set(['date','invoice date','تاريخ','تاريخ الفاتورة']),
    cli:  new Set(['bill to','customer','client','nom du client','اسم العميل','العميل','الزبون']),
    tel:  new Set(['phone','tel','telephone','téléphone','هاتف','تلفون','رقم الهاتف'])
  };

  const readLabeled = (labels) => {
    for (let r = 0; r < topRows; r++) {
      const A = _normLbl_(values[r]?.[0]);      // label in col A
      if (labels.has(A)) return toStr(values[r]?.[1]).trim();
      const B = _normLbl_(values[r]?.[1]);      // or label in col B
      if (labels.has(B)) return toStr(values[r]?.[2]).trim();
    }
    return '';
  };

  // total: scan top ~120 rows for TOTAL/SUBTOTAL (multi-language), take right neighbor
  let total = '';
  outer: for (let r = 0; r < Math.min(values.length, 120); r++) {
    const row = values[r] || [];
    for (let c = 0; c < Math.min(row.length, 10); c++) {
      const t = _normLbl_(row[c]);
      if (t.includes('sub total') || t.includes('subtotal') || t.includes('total usd') || t === 'total' ||
          t.includes('المجموع') || t.includes('الاجمالي')) {
        total = toStr(row[c + 1] ?? row[4] ?? '').trim();
        break outer;
      }
    }
  }

  return {
    invoice: readLabeled(labs.inv),
    date:    readLabeled(labs.date),
    client:  readLabeled(labs.cli),
    phone:   readLabeled(labs.tel),
    invoiceTotal: total
  };
}


/* ================================ Parsing / Listing ================================ */

// Parse “INV-XXX-YYYY” → { num, tag } or null
function parseInvAInfo_(name) {
  const m = /\bINV-(\d+)-(\d{4})\b/i.exec(String(name || ''));
  return m ? { num: parseInt(m[1], 10), tag: m[2] } : null;
}
// Parse “IPEC Invoice XXX-YYYY” anywhere in the name
function parseInvBInfo_(name) {
  const m = /IPEC\s*Invoice[^\d]*?(\d+)\s*-\s*(\d{4})/i.exec(String(name || ''));
  return m ? { num: parseInt(m[1], 10), tag: m[2] } : null;
}

// Latest {num, tag} by filenames in a folder
function getFolderMaxInfo_(folderId, parseInfoFn) {
  let best = { num: 0, tag: '' };
  const it = DriveApp.getFolderById(folderId).getFiles();
  while (it.hasNext()) {
    const f = it.next();
    const mt = f.getMimeType();
    const isExcel = (CFG.EXCEL_MIMES && CFG.EXCEL_MIMES.indexOf(mt) !== -1) || /\.xlsx?$/i.test(f.getName());
    if (!isExcel) continue;
    const info = parseInfoFn(f.getName());
    if (info && (info.tag > best.tag || (info.tag === best.tag && info.num > best.num))) best = info;
  }
  return best;
}

// Owner-agnostic listing across all drives for a given tag (YYYY)
function listFolderFilesForTag_(folderId, parseInfoFn, tag) {
  const items = listExcelFilesAllDrives_(folderId);
  const out = [];
  for (const it of items) {
    const info = parseInfoFn(it.name); // {num, tag}
    if (info && info.tag === tag) out.push({ file: DriveApp.getFileById(it.id), num: info.num, tag: info.tag });
  }
  Logger.log(`Folder ${folderId} tag ${tag}: found ${out.length} Excel file(s) across all drives.`);
  return out;
}

// All-Drives listing (Advanced Drive API v3)
function listExcelFilesAllDrives_(folderId) {
  const q = `'${folderId}' in parents and trashed=false and (` +
            `mimeType='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' or ` +
            `mimeType='application/vnd.ms-excel' or ` +
            `name contains '.xlsx' or name contains '.xls')`;
  const params = {
    q,
    corpora: 'allDrives',
    includeItemsFromAllDrives: true,
    supportsAllDrives: true,
    fields: 'files(id,name,mimeType),nextPageToken',
    pageSize: 1000
  };
  let items = [], token;
  do {
    if (token) params.pageToken = token;
    const res = Drive.Files.list(params);
    if (res && res.files) items = items.concat(res.files);
    token = res.nextPageToken;
  } while (token);
  return items;
}

/* ================================ Presence / Enrichment ================================ */

// Normalize names: lowercase, trim, strip .xls/.xlsx
function normalizeName_(s) { return String(s || '').toLowerCase().trim().replace(/\.(xlsx|xls)$/i, ''); }

// Master presence for Type+tag → exact names, urls, and normalized names
function listMasterPresenceForTypeTag_(sh, typeLetter, tag) {
  const out = { names: new Set(), urls: new Set(), normNames: new Set() };
  if (!tag) return out;
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return out;

  const vals = sh.getRange(2, 1, lastRow - 1, 3).getValues(); // A:name, B:url/path, C:type
  const parseInfo = (typeLetter === 'A') ? parseInvAInfo_ : parseInvBInfo_;

  for (let i = 0; i < vals.length; i++) {
    const name = toStr(vals[i][0]);
    const url  = toStr(vals[i][1]);
    const type = toStr(vals[i][2]).trim().toUpperCase();
    if (type !== typeLetter || !name) continue;

    const info = parseInfo(name); // { num, tag }
    if (info && info.tag === tag) {
      out.names.add(name);
      out.normNames.add(normalizeName_(name));
      if (url) out.urls.add(url);
    }
  }
  return out;
}

// Build a map: ITEMCODE -> { supplier, category, subcategory } from the Items tab
function loadItemsMap_(ssMaster) {
  const sh = ssMaster.getSheetByName(CFG.ITEMS_TAB);
  if (!sh) return new Map();
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return new Map();
  const lastCol = Math.max(
    CFG.ITEMS_KEY_COL, CFG.ITEMS_CATEGORY_COL, CFG.ITEMS_SUBCATEGORY_COL, CFG.ITEMS_SUPPLIER_COL
  );
  const values = readRangeValuesWithRetry_(sh.getRange(2, 1, lastRow - 1, lastCol)); // skip header
  const map = new Map();
  for (let i = 0; i < values.length; i++) {
    const row = values[i];
    const code = toStr(row[CFG.ITEMS_KEY_COL - 1]).trim().toUpperCase();
    if (!code) continue;
    const category    = toStr(row[CFG.ITEMS_CATEGORY_COL    - 1]).trim();
    const subcategory = toStr(row[CFG.ITEMS_SUBCATEGORY_COL - 1]).trim();
    const supplier    = toStr(row[CFG.ITEMS_SUPPLIER_COL    - 1]).trim();
    map.set(code, { supplier, category, subcategory });
  }
  return map;
}

/* ================================ Import utils ================================ */

// Excel (.xls/.xlsx) → temporary Google Sheet (Drive Advanced Service v3)
function importExcelToSheet_v3_(file) {
  const blob = file.getBlob();
  const meta = { name: stripExt_(file.getName()) + ' (Imported)', mimeType: 'application/vnd.google-apps.spreadsheet' };
  const res  = Drive.Files.create(meta, blob, { supportsAllDrives:true, fields:'id' });
  if (!res || !res.id) throw new Error('Excel import failed (no id).');
  return { spreadsheet: SpreadsheetApp.openById(res.id), toDelete: res.id };
}

// Prefer common invoice tabs; fallback to first visible
function pickDataSheet_(ss) {
  for (const nm of CFG.DATA_SHEET_CANDIDATES) {
    const sh = ss.getSheetByName(nm); if (sh) return sh;
  }
  const vis = ss.getSheets().filter(s => !s.isSheetHidden());
  return vis.length ? vis[0] : ss.getSheets()[0];
}

/* ================================ Retry wrappers / utils ================================ */

function tryWithRetry_(fn, tries, waitMs) {
  let lastErr;
  for (let i = 0; i < tries; i++) { try { return fn(); } catch (e) { lastErr = e; Utilities.sleep(waitMs); } }
  throw lastErr;
}
function openSpreadsheetWithRetry_(id) { return tryWithRetry_(() => SpreadsheetApp.openById(id), 3, 500); }
function readRangeValuesWithRetry_(range) { return tryWithRetry_(() => range.getValues(), 3, 400); }

function stripExt_(s) { return String(s).replace(/\.(xlsx|xls)$/i, ''); }
function toStr(v) { return (v === null || v === undefined) ? '' : String(v); }

/* ================================ Sheet helpers ================================ */

function getOrCreateSheetWithHeader_(ss, tabName, headerArray) {
  let sh = ss.getSheetByName(tabName);
  if (!sh) sh = ss.insertSheet(tabName);

  if (sh.getLastRow() === 0) {
    sh.getRange(1, 1, 1, headerArray.length).setValues([headerArray]);
    sh.setFrozenRows(1);
    return sh;
  }
  const existing = sh.getRange(1, 1, 1, headerArray.length).getValues()[0];
  const blank = existing.every(v => String(v ?? '').trim() === '');
  if (blank) {
    sh.getRange(1, 1, 1, headerArray.length).setValues([headerArray]);
    sh.setFrozenRows(1);
  }
  return sh;
}
const EXPECTED_MASTER_HEADERS = [
  'InvoiceName','InvoicePath','Type','Client','Phone','ItemCode','ProductDescription',
  'Qty','UnitPrice','LineTotal','InvoiceTotal','Supplier','Category','Sub-category','InvoiceDate'
];
const _norm = s => String(s||'').toLowerCase().replace(/[^a-z0-9]/g,'');

function resolveMasterGid_(sheetId, preferredTabName) {
  const ss = SpreadsheetApp.openById(sheetId);
  if (preferredTabName) {
    const sh = ss.getSheetByName(preferredTabName);
    if (sh) return { gid: String(sh.getSheetId()), name: sh.getName(), score: 999 };
  }
  const wanted = new Set(EXPECTED_MASTER_HEADERS.map(_norm));
  let best = { gid: '0', name: '', score: -1 };
  ss.getSheets().forEach(sh => {
    const n = Math.min(sh.getLastColumn(), 50);
    if (n < 2) return;
    const headers = sh.getRange(1,1,1,n).getValues()[0];
    const score = headers.reduce((s,h)=> s + (wanted.has(_norm(h)) ? 1 : 0), 0);
    if (score > best.score) best = { gid: String(sh.getSheetId()), name: sh.getName(), score };
  });
  return best;
}
function _authProbe_() {
  const url = 'https://www.googleapis.com/oauth2/v3/tokeninfo';
  const resp = UrlFetchApp.fetch(url, {
    headers: { Authorization: 'Bearer ' + ScriptApp.getOAuthToken() },
    muteHttpExceptions: true
  });
  Logger.log(resp.getResponseCode());
}
function _sheetAuthProbe_() {
  SpreadsheetApp.openById(CFG.MASTER_SHEET_ID).getName();
}
// =================== Backfill Product Descriptions (ALL ROWS) ===================

const PROP_BACKFILL_IDX = 'BACKFILL_ROW_IDX';

function BackfillDescriptionsFromInvoices_All_Gated() {
  if (!withinWindow_()) { Logger.log('Outside window; skipping Backfill'); return; }
  BackfillDescriptionsFromInvoices_All();
}

function BackfillDescriptionsFromInvoices_All() {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(30 * 1000)) { Logger.log('Backfill lock busy; skipping.'); return; }

  try {
    const props = PropertiesService.getDocumentProperties();
    const ss = openSpreadsheetWithRetry_(CFG.MASTER_SHEET_ID);
    const sh = ss.getSheetByName(CFG.MASTER_TAB);
    if (!sh) { Logger.log('Master sheet not found'); return; }

    const lastRow = sh.getLastRow();
    if (lastRow < 2) { Logger.log('No data rows'); return; }

    // Start from saved progress (2 = first data row)
    let i = parseInt(props.getProperty(PROP_BACKFILL_IDX) || '2', 10);
    if (isNaN(i) || i < 2) i = 2;

    const t0 = Date.now();
    const tLimit = CFG.TIME_GUARD_MS || 5 * 60 * 1000;

    while (i <= lastRow) {
      if (Date.now() - t0 > tLimit) {
        props.setProperty(PROP_BACKFILL_IDX, String(i));
        scheduleAutoContinueBackfill_();
        Logger.log('Time guard hit; paused at row ' + i);
        return;
      }

      const row = sh.getRange(i, 1, 1, CFG.OUT_HEAD.length).getValues()[0]; // A..O
      const type  = toStr(row[2]).trim().toUpperCase(); // C: Type (A/B)
      const path  = toStr(row[1]);                      // B: InvoicePath (expect Drive URL)
      const code  = toStr(row[5]).trim().toUpperCase(); // F: ItemCode
      const cur   = toStr(row[6]).trim();               // G: ProductDescription (current)

      // Always re-check (even if cur is non-empty)
      const fresh = tryReadDescFromInvoice_(path, type, code);
      if (fresh && fresh !== cur) {
        sh.getRange(i, 7).setValue(fresh); // column G
      }

      i++;
    }

    props.deleteProperty(PROP_BACKFILL_IDX);
    Logger.log('Backfill complete.');

  } finally {
    lock.releaseLock();
  }
}

// Extract description from the invoice file at the given URL for the given code
function tryReadDescFromInvoice_(invoiceUrl, type, itemCode) {
  try {
    const m = /[-\w]{25,}/.exec(String(invoiceUrl || '')); // Drive file id in URL
    if (!m) return '';
    const file = DriveApp.getFileById(m[0]);

    const openRes = importExcelToSheet_v3_(file);
    try {
      const dataSh = pickDataSheet_(openRes.spreadsheet);
      if (!dataSh) return '';
      const values = readRangeValuesWithRetry_(dataSh.getDataRange());

      // Use your readers (both force description from column B already)
      const rows = (String(type).toUpperCase() === 'A') ? readItemsA_(values) : readItemsB_(values);
      const hit  = rows.find(r => toStr(r.itemCode).trim().toUpperCase() === itemCode);
      return hit ? toStr(hit.description).trim() : '';
    } finally {
      if (CFG.CLEANUP_TEMP_IMPORTS && openRes.toDelete) {
        try { Drive.Files.delete(openRes.toDelete, { supportsAllDrives:true }); } catch(_) {}
      }
    }
  } catch (e) {
    Logger.log('Backfill read failed: ' + e);
    return '';
  }
}

function scheduleAutoContinueBackfill_() {
  try {
    ScriptApp.getProjectTriggers()
      .filter(t => t.getHandlerFunction && t.getHandlerFunction() === 'BackfillDescriptionsFromInvoices_All_Gated' &&
                   t.getEventType && t.getEventType() === ScriptApp.EventType.CLOCK)
      .forEach(t => { try { ScriptApp.deleteTrigger(t); } catch (_) {} });

    const when = nextAllowedTime_();
    ScriptApp.newTrigger('BackfillDescriptionsFromInvoices_All_Gated').timeBased().at(when).create();
    Logger.log('Backfill auto-continue scheduled: ' + when);
  } catch (err) {
    Logger.log('Backfill auto-continue skipped: ' + err);
  }
}

// Utility: start over from the very beginning
function BackfillDescriptions_ResetAndRun() {
  PropertiesService.getDocumentProperties().deleteProperty(PROP_BACKFILL_IDX);
  BackfillDescriptionsFromInvoices_All_Gated();
}
